var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"Arnoldi, J. -.-F.; Bideault, A.; Loreau, M. and Haegeman, B. (2018). How Ecosystems Recover from Pulse Perturbations: A Theory of Short- to Long-Term Responses. Journal of Theoretical Biology 436, 79–92. Accessed on Jan 23, 2024.\n\n\n\nGrimm, V. and Wissel, C. (1997). Babel, or the Ecological Stability Discussions: An Inventory and Analysis of Terminology and a Guide for Avoiding Confusion. Oecologia 109, 323–334, arXiv:4221528. Accessed on Oct 3, 2024.\n\n\n\nKeyes, A. A.; Barner, A. K. and Dee, L. E. (2024). Synthesising the Relationships Between Food Web Structure and Robustness. Ecology Letters 27, e14533. Accessed on Oct 28, 2024.\n\n\n\nLajaaiti, I.; Bonnici, I.; Kéfi, S.; Mayall, H.; Danet, A.; Beckerman, A. P.; Malpas, T. and Delmas, E. (2025). EcologicalNetworksDynamics.Jl: A Julia Package to Simulate the Temporal Dynamics of Complex Ecological Networks. Methods in Ecology and Evolution 16, 520–529. Accessed on Mar 5, 2025.\n\n\n\nLi, X.; Yang, W.; Novak, M.; Zhao, L.; de Ruiter, P. C.; Yang, Z. and Guill, C. (2025). Body Mass–Biomass Scaling Modulates Species Keystone-Ness to Press Perturbations. Ecology Letters 28, e70086. Accessed on Apr 3, 2025.\n\n\n\nNeubert, M. G. and Caswell, H. (1997). Alternatives to Resilience for Measuring the Responses of Ecological Systems to Perturbations. Ecology 78, 653–665. Accessed on Oct 27, 2022.\n\n\n\nNovak, M.; Yeakel, J. D.; Noble, A. E.; Doak, D. F.; Emmerson, M.; Estes, J. A.; Jacob, U.; Tinker, M. T. and Wootton, J. T. (2016). Characterizing Species Interactions to Understand Press Perturbations: What Is the Community Matrix? Annual Review of Ecology, Evolution, and Systematics 47, 409–432. Accessed on Jan 27, 2025.\n\n\n\n","category":"page"},{"location":"stability/#Stability","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"stability/","page":"Stability","title":"Stability","text":"This section covers how to analyse the stability of a community once simulated with EcologicalNetworksDynamics (Lajaaiti et al., 2025). Stability can be notoriously measured in many different ways (Grimm and Wissel, 1997). We provide in what follows an overview of the different stability metrics available from our package. We have aimed to implement the most common and used stability metrics.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"To begin we need to import the companion package.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"using EcoNetPostProcessing # Companion package - stability functions.","category":"page"},{"location":"stability/#Simulating-a-simple-community","page":"Stability","title":"Simulating a simple community","text":"","category":"section"},{"location":"stability/","page":"Stability","title":"Stability","text":"First, let's consider a simple community of a consumer feeding on a producer.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"using EcologicalNetworksDynamics\n\nfw = Foodweb([:consumer => :producer])\nm = default_model(fw)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Before going further, we can check species indices, which is going to useful for subsequent steps.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"m.species.index","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We see that species 1 is the consumer, and species 2 is the producer. We can simulate the dynamic of this simple model to find its steady-state.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"B0 = [1, 1] # Initial biomass.\nsol = simulate(m, B0, 1_000)\nBeq = sol[end]","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"At steady-state the consumer has a biomass near 0.39, and the producer has a biomass near 0.18.","category":"page"},{"location":"stability/#Computing-the-community-Jacobian","page":"Stability","title":"Computing the community Jacobian","text":"","category":"section"},{"location":"stability/","page":"Stability","title":"Stability","text":"Many stability metrics are derived from the Jacobian of the dynamical system. The Jacobian is simply a matrix whose elements specifies how species behave in face of a small disturbance. It tells for example if species are prone to go back quickly to their undisturbed state or, on the contrary, if species tend to go away.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We can compute the Jacobian of the community previously simulated. To do so, we need to specify two arguments:","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"m specifying the model\nB the vector of biomass where to evaluate the jacobian","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Most of the time B is going to be species biomass at equilibrium, as the Jacobian is particularly useful and relevant to perform the stability analysis near an equilibrium.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"In our setting, we have","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"j = jacobian(m, Beq)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Various stability metrics can be derived from the Jacobian (Arnoldi et al., 2018). The most common is by far the asymptotic resilience, formally defined as","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"textresilience = max_i Re(lambda_i(J))","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"where lambda_i denote the eigenvalues of the Jacobian J.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We can compute the resilience of the system with","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"resilience(j)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We expect a negative value, as we have seen that the equilibrium is stable. The more negative the resilience, the more stable the community is.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Another common stability metric derived from the Jacobian, that is increasingly used is the community reactivity. While the resilience gives the long-term recovery rate of the community, the reactivity informs on the contrary on the short-term recovery rate (Neubert and Caswell, 1997). It is formally defined as","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"textreactivity = max_i lambda_i (fracJ + J^T2)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"It more intuitively corresponds to the degree to which a disturbance can be amplified in the worst case scenario. It can be computed with","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"reactivity(j)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"A positive value means that the system can go away from its equilibrium after a disturbance, before eventually recovering.","category":"page"},{"location":"stability/#Sensitivity-matrix","page":"Stability","title":"Sensitivity matrix","text":"","category":"section"},{"location":"stability/","page":"Stability","title":"Stability","text":"While the Jacobian describes the community recovery near its equilibrium, after an instantaneous disturbance, it does not capture how species respond to sustained change in environmental conditions, such as an increase in mortality. The response to this type of disturbances (hereafter 'press') is captured by the sensitivity matrix. Elements of the sensitivity matrix for instance quantifies how an increase is species mortality affects the biomass of another species (Novak et al., 2016). The sensitivity matrix is simply the inverse of the interaction matrix. Because in our model interactions are density-dependent, the vector of species biomass (where to evaluate interactions) should be specified.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"A = get_interaction(m, Beq)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Formally, the interaction coefficients are defined as","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"A_ij = fracpartial (frac1B_ifractextd B_itextdt)partial B_j","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"that is the partial derivative of the growth rate of species i relative to a change in biomass of species j.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"In our toy example, we see that species 2 (producer) is self-regulated (A[2, 2] < 0). Moreover because species 1 feed on species 2 it receives a positive interaction (A[1, 2]), while species 2 receives a negative interaction (A[2, 1]). The sensitivity matrix can be directly computed","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"The sensivitiy matrix, being the inverse of the interaction matrix, informs on the inverse relationship","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"S_ij = fracpartial B_i^texteqpartial (frac1B_jfractextdB_jtextdt)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"that is how species equilibrium changes in response to variation in species growth rates. For example, how species biomass respond to an increase in mortality in other species.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"S = sensitivity(m, Beq)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We see that an increase in the producer mortality should not affect its biomass (S[2, 2]=0), while it should decrease the biomass of the consumer (S[1, 2]>0).","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"m.d[2] = 0.1 # Was set to 0 before.\nBnew = simulate(m, Beq, 1_000).u[end]\nBnew .- Beq","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"The sensitivity matrix can notably used to compute species resistance. Resistance quantifies how species respond to disturbance in others. Formally it is defined as","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"textresistance = fracDelta B_iDelta d_i","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"that is the ratio of the change in species biomass in response normalized by its increase in mortality rate.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"resistance(m, Beq)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Here resistance is derived from the sensitivity matrix, which assumes a small disturbance so that nonlinearities can be neglected. But resistance can be also computed from simulation with","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"resistance_simulation(m, Beq)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We see first that output values are close to the one returned resistance. The slight difference is explained by the nonlinearities of the species response which is not accounted for when using resistance. Furthermore, we see that species (that is, the consumer) is less resistant than the plant it feeds on (species 2). Ecologically speaking, this can be understood by the fact that when the mortality of both species increase the plant benefit from a release of the feeding pressure which offset its biomass loss. On the contrary, the consumer suffers even more as in addition of the increase in its mortality rate it also perceives a reduction in the amount of the plant it feeds on as the mortality of the plant also increases. In short, the difference in resistance value between two species translate their asymmetric relationship.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Both functions, resistance, resistance_simulation have multiple keyword arguments to specify which species is affected by the disturbance the response of which species should be measured, and if the measure should be aggregated (averaged) at the community level.","category":"page"},{"location":"stability/#Secondary-extinctions-and-robustness","page":"Stability","title":"Secondary extinctions and robustness","text":"","category":"section"},{"location":"stability/","page":"Stability","title":"Stability","text":"Another set of stability metrics focus on secondary extinctions (or cascading extinctions) (Keyes et al., 2024). Secondary extinctions measure the number of extinctions following the extinction of a first species. It informs on the importance, or more specifically the 'keystone-ness' (Li et al., 2025), of that species. If the extinction of that species result in many secondary extinctions, it means that the species is key for the community (or is a keystone species) as its presence allows many other species to coexist. On the contrary, if the number of secondary extinctions is null it means that the species is less important (regarding the community diversity at least).","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"In our toy example we can compute secondary_extinctions as follow","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"secondary_extinctions(m, 1, Beq) # Species 1 is set extinct.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"secondary_extinctions(m, 2, Beq) # Species 2 is set extinct.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We see that the extinction of the consumer leads to no secondary extinction, while the extinction of the plant leads to the extinction of the consumer that depends on it.","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We can compute at the level of the community, the extent to which a community is prone to secondary extinctions if a species goes extinct. This stability measure is given by the robustness. It is defined as the inverse of the number of secondary extinction we can expect. In our example, we have seen that we have two possibilities : ","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"The plant goes extinct first and we have one secondary extinction\nThe consumer goes extinct first and we have no secondary extinction","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"Therefore we expect a robustness value close to ","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"textrobustness_textexp = (frac1 + 02)^-1 = 2","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We can check this numerically with","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"robustness(m)","category":"page"},{"location":"stability/","page":"Stability","title":"Stability","text":"We do observe a value close to 2. The value is not exact because the computation is performed on a set of random extinction sequence, increasing this number with n_rep should result in the convergence of the robustness value towards 2 in this case.","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is a companion to   EcologicalNetworksDynamics.jl,   extending its functionality in two main directions:","category":"page"},{"location":"#Post-Processing-Simulation-Outputs","page":"Home","title":"Post-Processing Simulation Outputs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package offers a set of utility functions designed to simplify the analysis of simulation results generated by EcologicalNetworksDynamics.   These tools make it easy to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Identify surviving species at the end of a simulation,\nExtract the final time steps for targeted analysis,\nAnd more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For details, see the Utilities section.","category":"page"},{"location":"#Measuring-Stability","page":"Home","title":"Measuring Stability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package also implements a suite of commonly used ecological stability metrics, such as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Resilience\nResistance\nRobustness\nAnd more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These metrics can be directly evaluated on dynamical models defined using EcologicalNetworksDynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, refer to the Stability section.","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This module provides utility functions to simplify the post-processing and analysis of simulations from the main EcologicalNetworksDynamics workflow. It includes functions for extracting time series data, identifying the persistence of species, and other common tasks.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"note: Package Status\nThis package is under active development. Feedback and requests for new utility functions are highly welcome. Please open an issue on our GitHub repository to suggest improvements.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# Loading packages\nusing EcologicalNetworksDynamics, EcoNetPostProcessing\nusing StatsBase","category":"page"},{"location":"utils/#Extract-Time-Series","page":"Utilities","title":"Extract Time Series","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"A common task is to analyze the population dynamics of species over time, particularly focusing on the steady state reached at the end of a simulation. The extract_last_timesteps function is the primary tool for this.","category":"page"},{"location":"utils/#extract_last_timesteps","page":"Utilities","title":"extract_last_timesteps","text":"","category":"section"},{"location":"utils/#EcoNetPostProcessing.extract_last_timesteps","page":"Utilities","title":"EcoNetPostProcessing.extract_last_timesteps","text":"extract_last_timesteps(solution; idxs = nothing, quiet = false, kwargs...)\n\nReturns the biomass matrix of species x time over the last timesteps.\n\nArguments\n\nlast: the number of last timesteps to consider. A percentage can also be also be provided as a String ending by %. Defaulted to 1.\nidxs: vector of species indexes or names. Set to nothing by default.\nquiet: ignores warning issue while extracting timesteps before last species extinction\n\nIf idxs is an integer, it returns a vector of the species biomass instead of a matrix.\n\nExamples\n\njulia> fw = Foodweb([0 0; 1 0])\n       m = default_model(fw)\n       B0, t_end = [1, 1], 1_000\n       sol = simulate(m, B0, t_end);\n\njulia> last = extract_last_timesteps(sol; last = 1, idxs = [2, 1]);\n       last ≈ sol.u[end][[2, 1]]\ntrue\n\njulia> last = extract_last_timesteps(sol; last = 1, idxs = [\"s2\", \"s1\"]);\n       last ≈ sol.u[end][[2, 1]]\ntrue\n\njulia> last2 = extract_last_timesteps(sol; last = 1, idxs = [2])\n       last2 ≈ sol.u[end][[2]]\ntrue\n\njulia> last2 = extract_last_timesteps(sol; last = 1, idxs = \"s2\")\n       last2 ≈ sol.u[end][[2]]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Example: Analyzing Final Community State","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This example shows how to extract the last 100 time steps of a simulation to analyze the stable state of the community.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# Simulate a simple food web\nfw = Foodweb([0 0; 1 0]) # A -> B\nm = default_model(fw)\nB0 = [1.0, 0.5] # Initial biomass\nt_end = 10_000\nsol = simulate(m, B0, t_end)\n\n# Extract the last 100 timesteps for all species\nfinal_state = extract_last_timesteps(sol; last = 100)\n\n# Calculate the mean biomass of each species at equilibrium\nmean_equilibrium_biomass = mean(final_state, dims=2)\n\n# Extract only the last 10% of the simulation for species \"s2\" (the consumer)\nconsumer_final = extract_last_timesteps(sol; last = \"10%\", idxs = \"s2\")","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Key Points:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Use the last argument to specify either a fixed number of time steps (100) or a percentage of the total simulation (\"10%\").\nThe idxs argument allows you to select specific species by their index ([2, 1]) or name ([\"s2\", \"s1\"]).\nThe function returns a matrix where rows are species and columns are time points.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"utils/#Identify-Persisting-and-Extinct-Species","page":"Utilities","title":"Identify Persisting and Extinct Species","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"After a simulation, it's crucial to determine which species survived and which went extinct. The following functions help you identify species based on a biomass threshold at the end of the simulation.","category":"page"},{"location":"utils/#get_alive_species","page":"Utilities","title":"get_alive_species","text":"","category":"section"},{"location":"utils/#EcoNetPostProcessing.get_alive_species","page":"Utilities","title":"EcoNetPostProcessing.get_alive_species","text":"get_alive_species(solution; idxs = nothing, threshold = 0)\n\nReturns a tuple with species having a biomass above threshold at the end of a simulation.\n\nExamples\n\njulia> foodweb = Foodweb([0 0; 0 0]);\n       m = default_model(foodweb);\n       sol = simulate(m, [0, 0.5], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s2], idxs = [2])\n\njulia> sol = simulate(m, [0.5, 0], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s1], idxs = [1])\n\njulia> sol = simulate(m, [0.5, 0.5], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s1, :s2], idxs = [1, 2])\n\njulia> sol = simulate(m, [0, 0], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = Symbol[], idxs = Int64[])\n\n\n\n\n\n","category":"function"},{"location":"utils/#get_extinct_species","page":"Utilities","title":"get_extinct_species","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"While not directly exported for a solution (see note below), the logic for a single biomass vector is available. For a full solution, you can use the output of get_alive_species to infer extinct species.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Example: Classifying Species by their Fate","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"fw = Foodweb([0 0 0; 1 0 0; 0 1 0]) # A -> B -> C\nm = default_model(fw)\nsol = simulate(m, [1.0, 0.0, 0.2], 1_000; extinction_threshold = 1e-5) # B begins at 0, so B its consumer C will go extinct\n# Get the alive species at the end\nalive_species = get_alive_species(sol)\nprintln(\"Alive species: $(alive_species.species) at indices $(alive_species.idxs)\")\n# To find extinct species, we can get all species and find the difference\nall_species_indices = 1:size(sol, 1) # Indices 1 to N\nextinct_species_indices = setdiff(all_species_indices, alive_species.idxs)\nprintln(\"Extinct species indices: $extinct_species_indices\")\n# You can also check the final biomass directly\nfinal_biomass = sol.u[end]\nprintln(\"Final biomass: $final_biomass\")\n# Species with biomass <= 0 are extinct.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"fw = Foodweb([0 0 0; 1 0 0; 0 1 0]) # A -> B -> C\nm = default_model(fw)\nsol = simulate(m, [1.0, 0.0, 0.2], 1_000) # B begins at 0, so B its consumer C will go extinct\n# Get the alive species at the end, but Species 3 is not considered extinct\n# Because we did not set extinction threshold in simulate() and in get_alive_species()\nalive_species = get_alive_species(sol)\nprintln(\"Alive species: $(alive_species.species) at indices $(alive_species.idxs)\")\n# C will be also considered extinct if we set an extinction threshold\nalive_species = get_alive_species(sol; threshold = 1e-5)\nprintln(\"Alive species: $(alive_species.species) at indices $(alive_species.idxs)\")\n\n# Also work with a vector of biomass:.\nget_alive_species(vec(extract_last_timesteps(sol; last = 1)))\n# You can also use the reciprocal function ``get_extinct_species` on biomass vector:\nget_extinct_species(vec(extract_last_timesteps(sol; last = 1)))","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Key Points:","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"The threshold argument allows you to define the biomass level below which a species is considered extinct (default is 0).\nget_alive_species returns a named tuple (species, idxs) for easy access to both the names and the indices of surviving species.\nFor a simple vector of biomass values, you can use get_alive_species(vector) and get_extinct_species(vector) directly.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"utils/#Other-Utility-Functions","page":"Utilities","title":"Other Utility Functions","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"These functions are used internally by the main utilities but can also be helpful for advanced users building custom analysis pipelines.","category":"page"},{"location":"utils/#process_idxs","page":"Utilities","title":"process_idxs","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This function sanitizes and validates user-provided species indices or names, converting them into a consistent format for internal use.","category":"page"},{"location":"utils/#EcoNetPostProcessing.process_idxs","page":"Utilities","title":"EcoNetPostProcessing.process_idxs","text":"process_idxs(solution; idxs = nothing)\n\nCheck and sanitize the species indices or names provided (idxs). Used in extract_last_timesteps.\n\n\n\n\n\n","category":"function"},{"location":"utils/#get_extinction_timesteps","page":"Utilities","title":"get_extinction_timesteps","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"For more detailed extinction analysis, this function identifies not just if a species went extinct, but when it happened during the simulation.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Example: Find When Extinctions Occurred","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"# after a simulation\nfw = Foodweb([0 0 0; 1 0 0; 0 1 0]) # A -> B -> C\nm = default_model(fw)\nsol = simulate(m, [1.0, 0.0, 0.2], 1_000, extinction_threshold = 1e-5)\nextinction_data = EcoNetPostProcessing.get_extinction_timesteps(sol)\nfor (i, sp) in enumerate(extinction_data.species)\n    println(\"Species $sp (index $(extinction_data.idxs[i])) went extinct at timestep $(extinction_data.extinction_timestep[i])\")\nend","category":"page"},{"location":"docstrings/#Docstrings","page":"Functions","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#EcoNetPostProcessing.extract_last_timesteps-Tuple{Any}","page":"Functions","title":"EcoNetPostProcessing.extract_last_timesteps","text":"extract_last_timesteps(solution; idxs = nothing, quiet = false, kwargs...)\n\nReturns the biomass matrix of species x time over the last timesteps.\n\nArguments\n\nlast: the number of last timesteps to consider. A percentage can also be also be provided as a String ending by %. Defaulted to 1.\nidxs: vector of species indexes or names. Set to nothing by default.\nquiet: ignores warning issue while extracting timesteps before last species extinction\n\nIf idxs is an integer, it returns a vector of the species biomass instead of a matrix.\n\nExamples\n\njulia> fw = Foodweb([0 0; 1 0])\n       m = default_model(fw)\n       B0, t_end = [1, 1], 1_000\n       sol = simulate(m, B0, t_end);\n\njulia> last = extract_last_timesteps(sol; last = 1, idxs = [2, 1]);\n       last ≈ sol.u[end][[2, 1]]\ntrue\n\njulia> last = extract_last_timesteps(sol; last = 1, idxs = [\"s2\", \"s1\"]);\n       last ≈ sol.u[end][[2, 1]]\ntrue\n\njulia> last2 = extract_last_timesteps(sol; last = 1, idxs = [2])\n       last2 ≈ sol.u[end][[2]]\ntrue\n\njulia> last2 = extract_last_timesteps(sol; last = 1, idxs = \"s2\")\n       last2 ≈ sol.u[end][[2]]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.get_alive_species-Tuple{Any}","page":"Functions","title":"EcoNetPostProcessing.get_alive_species","text":"get_alive_species(solution; idxs = nothing, threshold = 0)\n\nReturns a tuple with species having a biomass above threshold at the end of a simulation.\n\nExamples\n\njulia> foodweb = Foodweb([0 0; 0 0]);\n       m = default_model(foodweb);\n       sol = simulate(m, [0, 0.5], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s2], idxs = [2])\n\njulia> sol = simulate(m, [0.5, 0], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s1], idxs = [1])\n\njulia> sol = simulate(m, [0.5, 0.5], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = [:s1, :s2], idxs = [1, 2])\n\njulia> sol = simulate(m, [0, 0], 20; show_degenerated = false);\n       get_alive_species(sol)\n(species = Symbol[], idxs = Int64[])\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.get_dBdt-Tuple{Model}","page":"Functions","title":"EcoNetPostProcessing.get_dBdt","text":"get_dBdt(m::Model)\n\nGenerate the function returning the vector of species growth rate (dB/dt) given the vector of their biomass (B), given a Model from EcologicalNetworksDynamics.\n\nThe output is aimed to be passed to the jacobian function of ForwardDiff. For more information see ForwardDiff documentation.\n\nSee also jacobian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.get_interaction-Tuple{Model, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.get_interaction","text":"get_interaction(m::Model, B::AbstractVector)\n\nCompute the interaction of the model m. Because interactions are density-dependent, the vectory of species biomass B should be specified. A[i, j] is the interaction from species j to species i, and is formally defined as the derivative of the per capita growth of species i with respect to variation in biomass of species j. See Novak et al. 2016.\n\nSee also sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.get_pgr-Tuple{Model}","page":"Functions","title":"EcoNetPostProcessing.get_pgr","text":"get_pgr(m::Model)\n\nGenerate the function returning the vector of species per capita growth rate (1/B x dB/dt) given the vector of their biomass (B), given a Model from EcologicalNetworksDynamics.\n\nSee also sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.keystoneness-Tuple{Model, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.keystoneness","text":"keystoneness(m::Model, B::AbstractVector)\n\nCompute species keystoneness from a given model m at the point given by the vector of species biomass B. Most of the time B should be the vector of species equilibrium biomass. Keystoneness of species i is defined as the sum abs(S[i, j]) for j different from i. It quantifies how a change in the growth rate of species i impacts all other species.\n\nFor a formal definition see Li et al. 2025.\n\nSee also sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.process_idxs-Tuple{Any}","page":"Functions","title":"EcoNetPostProcessing.process_idxs","text":"process_idxs(solution; idxs = nothing)\n\nCheck and sanitize the species indices or names provided (idxs). Used in extract_last_timesteps.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.reactivity-Tuple{AbstractMatrix}","page":"Functions","title":"EcoNetPostProcessing.reactivity","text":"reactivity(j::AbstractMatrix)\n\nCompute community reactivity from the jacobian. Reactivity corresponds to the worst initial response of the community to a pulse disturbance.\n\nFor technical details see Arnoldi et al. 2019\n\nSee also jacobian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.resilience-Tuple{AbstractMatrix}","page":"Functions","title":"EcoNetPostProcessing.resilience","text":"resilience(j::AbstractMatrix)\n\nCompute community resilience from the jacobian. Resilience corresponds here to the dominant eigenvalues of the Jacobian.\n\nFor technical details see Arnoldi et al. 2019\n\nSee also jacobian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.resistance-Tuple{Model, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.resistance","text":"resistance(m::Model, B::AbstractVector; response_of = :all, perturbation_on = :all, aggregated = false)\n\nCompute the resistance of species or the entire community to a press disturbance (such as an increase in mortality). Resistance computation is based on the sensitivity matrix. To get resistance computed from simulated dynamics use resistance_simulation.\n\nMain arguments\n\nm specifies the dynamical model.\nB is the vector of species equilibrium biomass.\n\nKeyword arguments\n\nresponse_of the response_of which species is measured, by default set to :all.\nperturbation_on which species is affected by the press, by default set to :all.\nagregated if true return the resistance on the species selected by response_of, can be used typically to compute the resistance at the community level. By default set to false, so that resistance is evaluated at the species level.\n\nSee also sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.resistance_simulation-Tuple{Model, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.resistance_simulation","text":"resistance_simulation(\nm::Model,\nB::AbstractVector;\nmortality_increment::AbstractVector = fill(0.1, m.richness),\nresponse_of = :all,\naggregated = false,\nnormalized = true,\n\n)\n\nCompute the resistance of species or group of species to a mortality increase. Resistance is computed from simulation outputs. For analytical computation see resistance. For small mortality_increment values both function should be equivalent.\n\nResistance is defined as the change in biomass relative to the mortality increment, when normalized is true. When normalized is false, the absolute change in biomass is returned.\n\nWhen aggregated is set to true, the total change in biomass is computed, and is normalized by the mean mortality increment.\n\nNote that if normalized is true and the mortality increment of species is set to 0, its resistance value will be set to :undefined because of division by 0. To bypass this behaviour, set :normalized to false, and then use the normalization of your choice on the output.\n\nMain arguments\n\nm specifies the dynamical model.\nB is the vector of species equilibrium biomass.\n\nKeyword arguments\n\nresponse_of the response_of which species is measured, by default set to :all.\nmortality_increment vector which species the increase in mortality rate for each species.\nagggregated if true return the resistance on the species selected by response_of, can be used typically to compute the resistance at the community level. By default set to false, so that resistance is evaluated at the species level.\nnormalized is the change in biomass normalized by the mortality increment. By default set to true.\n\nSee also sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.robustness-Tuple{Model}","page":"Functions","title":"EcoNetPostProcessing.robustness","text":"robustness(m::Model; t_end = 1_000, n_rep = 100, threshold = 1e-6)\n\nCompute the community robustness. Robustness is defined as the inverse of the number of secondary extinctions. The number of average number of secondary extinctions is averaged over n_rep random extinction sequences. Each extinction sequences set the order of species extinction, and terminate when all species are extinct.\n\nMain argument\n\nm specifies the community.\n\nKeyword arguemnts\n\nt_end simulation duration (default to 1_000)\nn_rep number of extinction sequences (default to 100)\nthreshold biomass value under which species are considered extinct (default to 1e-6)\n\nSee also secondary_extinctions.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.secondary_extinctions-Tuple{Model, Integer, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.secondary_extinctions","text":"secondary_extinctions(\nm::Model,\nextinct_sp::Integer,\nB_start::AbstractVector;\nt_end = 1_000,\nthreshold = 1e-6,\n\n)\n\nCompute secondary extinctions following the primary extinction of extinct_sp of a model m with initial biomasses B_start.\n\nKeyword arguments\n\nt_end specifies the duration of simulation\nthreshold gives the biomass below which a species is considered extinct.\n\nSee also robustness.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#EcoNetPostProcessing.sensitivity-Tuple{Model, AbstractVector}","page":"Functions","title":"EcoNetPostProcessing.sensitivity","text":"sensitivity(m::Model, B::AbstractVector)\n\nCompute the sensitivity matrix of the model m. Because interactions are density-dependent, the vectory of species biomass B should be specified. The sensitivity matrix is defined as the inverse of the interaction matrix. See Novak et al. 2016.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#ForwardDiff.jacobian-Tuple{Model, AbstractVector}","page":"Functions","title":"ForwardDiff.jacobian","text":"jacobian(m::Model, B::AbstractVector)\n\nCompute the jacobian of the system specied by the model B. The jacobian is evaluated in B which gives species biomass.\n\n\n\n\n\n","category":"method"}]
}
